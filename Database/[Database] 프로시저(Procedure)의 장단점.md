# 프로시저의 장단점
- 프로시저는 특정 작업을 수행하는 코드 블록이다.

- 데이터베이스에 저장된 SQL 코드 블록으로, 파라미터를 받아 복잡한 로직을 실행한다.

**간단한 프로시저 예시**
```sql
CREATE eigenen PROCEDURE GetUserOrders(
    IN userId INT,
    OUT orderCount INT
)
BEGIN
    SELECT * FROM orders WHERE user_id = userId;
    SELECT COUNT(*) INTO orderCount FROM orders WHERE user_id = userId;
END;
```
<br>

**호출 방법**
```sql
CALL GetUserOrders(123, @count);
SELECT @count;
```
<br>
<hr>
<br>

## ✔️ 장점
### 성능 향상
- SQL 코드가 DB 내부에 저장되어 네트워크 트래픽 감소

- 컴파일된 상태로 실행 가능
<br>

### 보안 강화
- SQL 인젝션 방지 용이
<br>

### 코드 재사용성
- 동일한 로직을 여러 곳에서 호출 가능

- 중복 코드 제거
<br>

### 비즈니스 로직 중앙화
- 복잡한 로직을 DB 서버에서 관리

- 로직 변경 시 프로시저만 수정(서버 재실행 불필요)
<br>

### 트랜잭션 관리 용이
- 여러 쿼리를 하나의 트랜잭션으로 묶어 실행 가능
<br>
<hr>
<br>

## ✔️ 단점
### tree affinity (DB 종속성)
- DB 벤더별 문법 차이로 이식성 저하

- DB 변경 시 마이그레이션 비용 증가
<br>

### 버전 관리 어려움
- SQL 파일 관리 필요
  - 프로젝트 소스에 프로시저 파일을 업로드해야 형상 관리가 된다.

- 코드 리뷰/테스트런트 자동화에 불리
<br>

### 디버깅/테스팅
- IDE 지원 제한

- 단위 테스트 작성이 어려움
<br>

### 로직 분산
- 애플리케이션 로직이 DB와 분리되어 관리 복잡
  - 애플리케이션 내에서 직접 DB를 다루지 않으므로 별도의 관리가 필요함
  - ex) Java의 Mybatis 사용 시 xml 파일안에 프로시저 파일명을 호출하므로 어떤 쿼리가 실행되는지 알 수 없음
<br>

### 확장성 제약
- DB 서버 리소스 사용 증가

- 로직이 복잡해질수록 유지보수가 어려워 진다.
<br>
<hr>
<br>

## ✔️ 언제 사용하면 좋을까?
### 사용하기 좋은 경우
- 복잡한 데이터 집계/보고서 작업

- 대량 데이터 일괄 처리

- 보안이 중요한 금융/결제 로직

- 자주 실행되는 복잡한 쿼리
<br>

### 사용하지 않는 것이 좋은 경우
- 단순한 CRUD 작업

- ORM 사용 시 (ex. JPA, Sequelize)

- MSA (로직이 분산됨)

- 빠르게 변경되는 로직
<br>
<hr>
<br>

## ✔️ 정리
- 저장 프로시저는 성능과 보안에 유리하지만, 유지보수와 이식성에 취약하다.

- 프로젝트 상황에 따라 선택이 필요하다.

- 무분별한 프로시저 사용은 지양해야 한다.
